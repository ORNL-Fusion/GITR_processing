import numpy as npimport numpy.matlib as mlimport matplotlib.pyplot as pltimport netCDF4import scipy.interpolate as sciidef init(W_indices, gitr_rz='assets/gitr_rz.txt'):    profilesFile = '../input/plasmaProfiles.nc'    profiles = netCDF4.Dataset(profilesFile)        #import wall geometry to plot over    with open(gitr_rz, 'r') as file:        wall = file.readlines()            r_wall = np.zeros(len(wall))    z_wall = np.zeros(len(wall))    for i,line in enumerate(wall):        point = line.split()        r_wall[i] = float(point[0])        z_wall[i] = float(point[1])        #check which target is the region of interest    print('W indices along coarse b2f target:\n',W_indices)    r_inner_target = profiles.variables['r_inner_target'][:][W_indices]    z_inner_target = profiles.variables['z_inner_target'][:][W_indices]    rmrs = profiles.variables['rmrs_inner_target_midpoints'][:][W_indices]        #plot r,z to check that target indices are restricted to W surfaces    plt.close()    plt.plot(r_inner_target, z_inner_target)        #set plotting style defaults    plt.rcParams.update({'font.size':11})    plt.rcParams.update({'lines.linewidth':1.2})    plt.rcParams.update({'lines.markersize':1})    return profiles, W_indices, r_wall, z_wall, r_inner_target, z_inner_target, rmrsdef readEquilibrium(equilibrium_filename, W_indices, solps_geom, \    solps_mesh_extra = None, plot_variables = 0):        profiles, W_indices, r_wall, z_wall, r_target, z_target, rmrs = init(W_indices)    rr=0    zz=0    pp=0    r = []    z = []    psi = []    with open(equilibrium_filename) as openfileobject:        for line in openfileobject:            if line:                    l = line.split()                    if not l:                        k=1                    else:                        if (l[0] == "jm" and l[1]=="="):                            jm = int(l[2])                        if (l[0] == "km" and l[1]=="="):                            km = int(l[2])                        if (l[0] == "psib" and l[1]=="="):                            psib = float(l[2])                        if (l[0] == "btf" and l[1]=="="):                            btf = float(l[2])                        if (l[0] == "rtf" and l[1]=="="):                            rtf = float(l[2])                        if (l[0] == "((psi(j,k)-psib,j=1,jm),k=1,km)" or pp==1):                            if pp:                                ll=[float(i) for i in l]                                psi = np.concatenate([psi, ll])                            zz=0;                            pp=1;                        if (l[0] == "z(1:km);" or zz==1):                            if zz:                                ll=[float(i) for i in l]                                z = np.concatenate([z, ll])                            rr=0;                            zz=1;                        if (l[0] == "r(1:jm);" or rr==1):                            if rr:                                ll=[float(i) for i in l]                                r = np.concatenate([r, ll])                            rr=1;    if solps_mesh_extra!=None:        #get geometry to plot on top of magnetic fields / fluxes        solps_mesh = np.loadtxt(solps_mesh_extra)        r_wall = solps_mesh[:, [0,2]].transpose()        z_wall = solps_mesh[:, [1,3]].transpose()    print ('Equ data dimensions %i by %i ' %(jm,km)	)    psi = np.reshape(psi,[len(z),len(r)])    if plot_variables==1:        # set the limits of the plot to the limits of the data        plt.axis([r.min(), r.max(), z.min(), z.max()])        plt.pcolor(r, z, psi)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlabel('r [m]')        plt.ylabel('z [m]')        plt.title('Magnetic Flux')        plt.colorbar(label='Flux [Wb/rad')        print( 'Saving psi function as psi.png ')        plt.savefig('plots/bfield/psi.pdf')        plt.close()        # set the limits of the plot to the limits of the data        plt.axis([r.min(), r.max(), z.min(), z.max()])        plt.contour(r,z,psi,1000)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlim(1.4,1.6)        plt.ylim(1.0,1.25)        plt.xlabel('r [m]')        plt.ylabel('z [m]')        plt.title('Magnetic Flux Contours')        plt.colorbar(label='Flux [Wb/rad]')        print ('Saving psi contour as psiContour.png ')        plt.savefig('plots/bfield/psiContour.png')        plt.close()    print('Take gradients of magnetic flux to produce magnetic field')    [gradz,gradr] = np.gradient(np.array(psi),z[1]-z[0],r[1]-r[0])    br = -gradz/r    bz =gradr/r        Bp = np.sqrt(np.multiply(br,br) + np.multiply(bz,bz))    bt = ml.repmat(btf*rtf/r,len(z),1)    bt = np.reshape(bt,[len(z),len(r)])    if plot_variables==1:        plt.pcolor(r,z,br)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlabel('r [m]')        plt.ylabel('z [m]')        plt.title('Br')        plt.colorbar(label='B field [T]')        print ('Saving br profile as br.png ')        plt.savefig('plots/bfield/br.pdf')        plt.close()            plt.pcolor(r,z,bz)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlabel('r [m]')        plt.ylabel('z [m]')        plt.title('Bz')        plt.colorbar(label='B field [T]')        print ('Saving bz profile as bz.png ')        plt.savefig('plots/bfield/bz.pdf')        plt.close()        plt.pcolor(r,z,bt)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlabel('r [m]')        plt.ylabel('z [m]')        plt.title('Bt')        plt.colorbar(label='B field [T]')        print( 'Saving bt profile as bt.png ')        plt.savefig('plots/bfield/bt.pdf')        plt.close()    rootgrp = netCDF4.Dataset("bField.nc", "w", format="NETCDF4")    nrr = rootgrp.createDimension("nR", len(r))    nzz = rootgrp.createDimension("nZ", len(z))    brr = rootgrp.createVariable("br","f8",("nZ","nR"))    btt = rootgrp.createVariable("bt","f8",("nZ","nR"))    bzz = rootgrp.createVariable("bz","f8",("nZ","nR"))    psii = rootgrp.createVariable("psi","f8",("nZ","nR"))    rr = rootgrp.createVariable("r","f8",("nR"))    zz = rootgrp.createVariable("z","f8",("nZ"))    brr[:] = br    btt[:] = bt    bzz[:] = bz    psii[:] = psi    rr[:] = r    zz[:] = z    rootgrp.close()    print( 'finishing read equilibirium')    return r,z,br, bz, bt,psidef plot_surf_plasma_params(W_surf):    profiles, W_indices, r_wall, z_wall, r_target, z_target, rmrs = init(W_surf)        #store plasma parameters for cells along the W surfaces as a function of rmrs    rmrs = profiles.variables['rmrs_inner_target_midpoints'][W_surf]    Bmag = profiles.variables['Bmag_inner_target'][W_surf]    Bangle = 180-profiles.variables['Bangle_inner_target'][W_surf]    te = profiles.variables['te_inner_target'][W_surf]    ti = profiles.variables['ti_inner_target'][W_surf]    ne = profiles.variables['ne_inner_target'][W_surf]    ni = profiles.variables['ni_inner_target'][:,W_surf]    flux = profiles.variables['flux_inner_target'][:,W_surf]    flux = np.abs(flux)        #plot magnitude of B-field    plt.close()    plt.plot(rmrs,Bmag)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Magnetic Field Strength [T]')    plt.title('B-field magnitude along W surface')    plt.savefig('plots/surface-profiles/Bmag.png')            #find points of interest on B-field angle    rmrs0=rmrs[4:10]    Bangle0=Bangle[4:10]    #print(np.where(Bangle==min(Bangle)))        #plot angle between B-field and normal incidence to the wall    plt.close()    plt.plot(rmrs,Bangle, linewidth=3)    plt.axvline(x=rmrs[4], color='k', linestyle='dotted')    plt.axvline(x=rmrs[10], color='k', linestyle='dotted')    #plt.axvline(x=rmrs[11], color='k', linestyle='dotted')    #plt.axvline(x=rmrs[12], color='k', linestyle='dotted')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Angle [$\circ$]')    plt.title('B-field angle along W surface')    plt.savefig('plots/surface-profiles/Bangle.png')        #plot te along the W surfaces    plt.close()    plt.plot(rmrs,te)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Temperature [eV]')    plt.title('Electron temperature along W surface')    plt.savefig('plots/surface-profiles/te.png')        #plot ti along the W surfaces    plt.close()    plt.plot(rmrs,ti)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Temperature [eV]')    plt.title('Ion temperature along W surface')    plt.savefig('plots/surface-profiles/ti.png')        #plot ne along the W surfaces    plt.close()    plt.plot(rmrs,ne)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Density [m$^{-3}$]')    plt.title('Electron density along W surface')    plt.savefig('plots/surface-profiles/ne.png')        #plot average ni along the W surfaces    plt.close()    ni_avg = np.average(ni, axis=0)    plt.plot(rmrs,ni_avg)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Density [m$^{-3}$]')    plt.title('Average ion density along W surface')    plt.savefig('plots/surface-profiles/niAvg.png')        #plot ni along the W surfaces for deuterium    plt.close()    plt.plot(rmrs,ni[0],color='k',label='D 0')    plt.plot(rmrs,ni[1],color='firebrick',label='D 1+')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Density [m$^{-3}$]')    plt.title('D ion density along W surface')    plt.legend()    plt.savefig('plots/surface-profiles/niD.png')        #plot flux along the W surfaces for deuterium    plt.close()    plt.plot(rmrs,flux[0],color='k',label='D 0')    plt.plot(rmrs,flux[1],color='firebrick',label='D 1+')    plt.axvline(x=rmrs[4], color='k', linestyle='dotted')    plt.axvline(x=rmrs[10], color='k', linestyle='dotted')    #plt.axvline(x=rmrs[11], color='k', linestyle='dotted')    #plt.axvline(x=rmrs[12], color='k', linestyle='dotted')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Flux [m$^{-2}$s$^{-1}$]')    plt.title('D ion flux to W surface')    plt.legend()    plt.savefig('plots/surface-profiles/fluxD.png')        #plot ni along the W surfaces for carbon    plt.close()    plt.plot(rmrs,ni[2],color='k',label='C 0')    plt.plot(rmrs,ni[3],color='firebrick',label='C 1+')    plt.plot(rmrs,ni[4],color='darkorange',label='C 2+')    plt.plot(rmrs,ni[5],color='gold',label='C 3+')    plt.plot(rmrs,ni[6],color='limegreen',label='C 4+')    plt.plot(rmrs,ni[7],color='dodgerblue',label='C 5+')    plt.plot(rmrs,ni[8],color='mediumpurple',label='C 6+')    plt.yscale('log')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Density [m$^{-3}$]')    plt.title('C ion density along W surface')    plt.legend(loc='lower right')    plt.savefig('plots/surface-profiles/niC.png')        #plot flux along the W surfaces for carbon    plt.close()    #plt.rcParams.update({'font.size':16})    #plt.rcParams.update({'lines.linewidth':3})        plt.axvline(x=rmrs[4], color='k', linestyle='dotted', label='\u0394\u03A8$_B$')    plt.axvline(x=rmrs[10], color='k', linestyle='dotted')    #plt.axvline(x=rmrs[11], color='k', linestyle='dotted')    #plt.axvline(x=rmrs[12], color='k', linestyle='dotted')        plt.plot(rmrs,flux[3],color='firebrick',label='C$^{1+}$')    plt.plot(rmrs,flux[4],color='darkorange',label='C$^{2+}$')    plt.plot(rmrs,flux[5],color='gold',label='C$^{3+}$')    plt.plot(rmrs,flux[6],color='limegreen',label='C$^{4+}$')    plt.plot(rmrs,flux[7],color='dodgerblue',label='C$^{5+}$')    plt.plot(rmrs,flux[8],color='mediumpurple',label='C$^{6+}$')        plt.xlim(-0.06)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Flux [m$^{-2}$s$^{-1}$]')    #plt.yticks(fontsize=10.5)    plt.title('C Ion Flux to W Surface', fontsize=20)    plt.legend()    plt.savefig('plots/surface-profiles/fluxC.png')        #electron temperature dependence of ionization rate    kte = np.arange(1,35,0.01)    x0 = 7.86    x1 = 16.37    x2 = 26.0    x3 = 38.2    x4 = 51.6    invtau0 = 1/(np.exp(x0/kte)/np.sqrt(kte))    invtau1 = 1/(np.exp(x1/kte)/np.sqrt(kte))    invtau2 = 1/(np.exp(x2/kte)/np.sqrt(kte))    invtau3 = 1/(np.exp(x3/kte)/np.sqrt(kte))    invtau4 = 1/(np.exp(x4/kte)/np.sqrt(kte))    plt.close()    plt.plot(kte, invtau0, 'red', label='0 to 1')    plt.plot(kte, invtau1, 'darkorange', label='1 to 2')    plt.plot(kte, invtau2, 'gold', label='2 to 3')    plt.plot(kte, invtau3, 'green', label='3 to 4')    plt.plot(kte, invtau4, 'blue', label='4 to 5')    plt.xlabel('Te [eV]')    plt.ylabel('Relative Ionization Rate [1/s]')    plt.title('Te Dependence of Ionization Rate for W')    plt.legend()    plt.savefig('plots/surface-profiles/IonizRate(Te)')        #ionization rate along surface    surf_IonizRate0 = ne/(np.exp(x0/te)/np.sqrt(te))    surf_IonizRate1 = ne/(np.exp(x1/te)/np.sqrt(te))    surf_IonizRate2 = ne/(np.exp(x2/te)/np.sqrt(te))    surf_IonizRate3 = ne/(np.exp(x3/te)/np.sqrt(te))    surf_IonizRate4 = ne/(np.exp(x4/te)/np.sqrt(te))    plt.close()    plt.plot(rmrs, surf_IonizRate0, 'red', label='0 to 1')    plt.plot(rmrs, surf_IonizRate1, 'darkorange', label='1 to 2')    plt.plot(rmrs, surf_IonizRate2, 'gold', label='2 to 3')    plt.plot(rmrs, surf_IonizRate3, 'green', label='3 to 4')    plt.plot(rmrs, surf_IonizRate4, 'blue', label='4 to 5')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Relative Ionization Rate [1/s]')    plt.title('W Ionization Rate along SAS-VW')    plt.legend()    plt.savefig('plots/surface-profiles/IonizRate')    returndef plot_2D_cross_sections(W_surf, varString, saveBool=False):    #useful for comparing against SOLPS-profiles to see what GITR sees    #GITR gets 2D profiles        profiles, W_indices, r_wall, z_wall, r_target, z_target, rmrs = init(W_surf)        gridr = profiles.variables['gridr'][:]    gridz = profiles.variables['gridz'][:]    var = profiles.variables[varString][:]        plt.rcParams.update({'pcolor.shading':'auto'})    plt.rcParams.update({'image.cmap':'plasma'})    plt.pcolor(gridr,gridz,var)    plt.plot(r_wall, z_wall, 'k-')    plt.plot(r_target, z_target, 'r-')    plt.colorbar()    plt.axis('Scaled')    plt.xlabel('r [m]')    plt.ylabel('z [m]')    plt.title(str(varString))    if saveBool: plt.savefig('plots/3D_profiles/'+str(varString))    def compare_surface_profiles(W_surf, varString):    profiles, W_indices, r_wall, z_wall, r_target, z_target, rmrs = init(W_surf)        #get SOLPS values along the target surface    varSOLPS = profiles.variables[varString+'_inner_target'][W_surf]    print('length of SOLPS var:',len(rmrs))        #interpolate GITR values along the target    gridz = profiles.variables['gridz'][:]    gridr = profiles.variables['gridr'][:]    varGITRgrid = profiles.variables[varString][:]    r_target = profiles.variables['r_inner_target_midpoints'][:][W_indices]    z_target = profiles.variables['z_inner_target_midpoints'][:][W_indices]        varGITR = scii.interpn((gridz,gridr),varGITRgrid,(z_target,r_target))    print('length of GITR var:',len(varGITR))        #plot and compare visually    plt.close()    plt.plot(rmrs,varSOLPS,'dodgerblue',label='SOLPS')    plt.plot(rmrs,varGITR,'gold',label='GITR')    plt.title(varString+' compared between grids')    plt.xlabel('D-Dsep [m]')    plt.ylabel(varString)    plt.legend()    plt.savefig('plots/gridComparison/compare_'+varString+'.png')if __name__ == "__main__":    compare_surface_profiles(np.arange(10,24),'ne')    #plot_2D_cross_sections(np.arange(10,24), 'vt')    #plot_surf_plasma_params(np.arange(10,24))    #init()