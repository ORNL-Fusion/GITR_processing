import numpy as npimport numpy.matlib as mlimport matplotlib.pyplot as pltimport matplotlib as mplimport netCDF4import scipy.interpolate as sciidef init(W_indices, gitr_rz='assets/gitr_rz.txt'):    profilesFile = '../input/plasmaProfiles.nc'    profiles = netCDF4.Dataset(profilesFile)        #import wall geometry to plot over    with open(gitr_rz, 'r') as file:        wall = file.readlines()            r_wall = np.zeros(len(wall))    z_wall = np.zeros(len(wall))    for i,line in enumerate(wall):        point = line.split()        r_wall[i] = float(point[0])        z_wall[i] = float(point[1])        #check which target is the region of interest    #print('W indices along coarse b2f target:\n',W_indices)    #W_indices_coords = np.append(W_indices, W_indices[-1]+1)    r_inner_target = profiles.variables['r_inner_target'][:][W_indices]    z_inner_target = profiles.variables['z_inner_target'][:][W_indices]    rmrs = profiles.variables['rmrs_inner_target_midpoints'][:][W_indices][:-1]        '''    #debugging    #plot r,z to check that target indices are restricted to W surfaces    plt.close()    plt.plot(r_inner_target, z_inner_target)    plt.axis('scaled')    plt.show(block=True)    '''        #set plotting style defaults    plt.rcParams.update({'font.size':11})    plt.rcParams.update({'lines.linewidth':1})    plt.rcParams.update({'lines.markersize':1})    plt.rcParams.update({'image.cmap':'rainbow'})    return profiles, r_wall, z_wall, r_inner_target, z_inner_target, rmrsdef readEquilibrium(equilibrium_filename, W_indices, solps_geom, \    solps_mesh_extra = None, flip_Bt=True, plot_variables = 0):        profiles, r_wall, z_wall, r_target, z_target, rmrs = init(W_indices)    rr=0    zz=0    pp=0    r = []    z = []    psi = []    with open(equilibrium_filename) as openfileobject:        for line in openfileobject:            if line:                    l = line.split()                    if not l:                        k=1                    else:                        if (l[0] == "jm" and l[1]=="="):                            jm = int(l[2])                        if (l[0] == "km" and l[1]=="="):                            km = int(l[2])                        if (l[0] == "psib" and l[1]=="="):                            psib = float(l[2])                        if (l[0] == "btf" and l[1]=="="):                            btf = float(l[2])                        if (l[0] == "rtf" and l[1]=="="):                            rtf = float(l[2])                        if (l[0] == "((psi(j,k)-psib,j=1,jm),k=1,km)" or pp==1):                            if pp:                                ll=[float(i) for i in l]                                psi = np.concatenate([psi, ll])                            zz=0;                            pp=1;                        if (l[0] == "z(1:km);" or zz==1):                            if zz:                                ll=[float(i) for i in l]                                z = np.concatenate([z, ll])                            rr=0;                            zz=1;                        if (l[0] == "r(1:jm);" or rr==1):                            if rr:                                ll=[float(i) for i in l]                                r = np.concatenate([r, ll])                            rr=1;    if solps_mesh_extra!=None:        #get geometry to plot on top of magnetic fields / fluxes        solps_mesh = np.loadtxt(solps_mesh_extra)        r_wall = solps_mesh[:, [0,2]].transpose()        z_wall = solps_mesh[:, [1,3]].transpose()    print ('Equ data dimensions %i by %i ' %(jm,km)	)    psi = np.reshape(psi,[len(z),len(r)])        if plot_variables==1:        # set the limits of the plot to the limits of the data        plt.axis([r.min(), r.max(), z.min(), z.max()])        plt.pcolor(r, z, psi)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlabel('R [m]')        plt.ylabel('Z [m]')        plt.title('Magnetic Flux')        plt.colorbar(label='Flux [Wb/rad]')        print('Saving psi function as psi.pdf')        plt.savefig('plots/bfield/psi.pdf')        plt.close()                # set the limits of the plot to the limits of the data        plt.axis([r.min(), r.max(), z.min(), z.max()])        plt.contour(r,z,psi,1000)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlim(1.4,1.6)        plt.ylim(1.0,1.25)        plt.xlabel('R [m]')        plt.ylabel('Z [m]')        plt.title('Magnetic Flux Contours')        plt.colorbar(label='Flux [Wb/rad]')        print ('Saving psi contour as psiContour.pdf')        '''        ##check gradTi in parallel direction                gridr = profiles.variables['gridr'][:]        gridz = profiles.variables['gridz'][:]        gradTi = profiles.variables['gradTi'][:]        plot = plt.pcolor(gridr,gridz,gradTi)                plt.rcParams.update({'pcolor.shading':'auto'})        plt.rcParams.update({'image.cmap':'coolwarm'})        colorbarLimits = [-15,15]        plt.colorbar(label='\n gradTi [eV/m]')        plot.set_clim(vmin=colorbarLimits[0],vmax=colorbarLimits[1])        '''        plt.show(block=False)                plt.savefig('plots/bfield/psiContour.png')        plt.close()            print('Take gradients of magnetic flux to produce magnetic field')    [gradz,gradr] = np.gradient(np.array(psi),z[1]-z[0],r[1]-r[0])    br = gradz/r    bz = -gradr/r        Bp = np.sqrt(np.multiply(br,br) + np.multiply(bz,bz))    bt = ml.repmat(btf*rtf/r,len(z),1)    bt = np.reshape(bt,[len(z),len(r)])        if flip_Bt:         bt = -bt        br = br        bz = bz    if plot_variables==1:        plt.close()        plt.rcParams.update({'image.cmap':'rainbow'})        p=plt.pcolor(r,z,br)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlabel('R [m]')        plt.ylabel('Z [m]')        plt.title('Br')        plt.colorbar(label='B-field [T]')        p.set_clim(vmin=-0.4,vmax=0.4)        print ('Saving br profile as br.pdf')        plt.savefig('plots/bfield/br.pdf')                plt.close()        p=plt.pcolor(r,z,bz)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlabel('R [m]')        plt.ylabel('Z [m]')        plt.title('Bz')        plt.colorbar(label='B-field [T]')        p.set_clim(vmin=-0.4,vmax=0.4)        print ('Saving bz profile as bz.pdf')        plt.savefig('plots/bfield/bz.pdf')        plt.close()        plt.rcParams.update({'image.cmap':'rainbow'})        p=plt.pcolor(r,z,bt)        plt.plot(r_wall, z_wall, 'k-')        plt.plot(r_target, z_target, 'r-')        plt.axis('Scaled')        plt.xlabel('R [m]')        plt.ylabel('Z [m]')        plt.title('Bt')        plt.colorbar(label='B-field [T]')        #p.set_clim(vmax=4)        print( 'Saving bt profile as bt.pdf')        plt.savefig('plots/bfield/bt.pdf')        plt.close()            rootgrp = netCDF4.Dataset("bField.nc", "w", format="NETCDF4")    nrr = rootgrp.createDimension("nR", len(r))    nzz = rootgrp.createDimension("nZ", len(z))    brr = rootgrp.createVariable("br","f8",("nZ","nR"))    btt = rootgrp.createVariable("bt","f8",("nZ","nR"))    bzz = rootgrp.createVariable("bz","f8",("nZ","nR"))    psii = rootgrp.createVariable("psi","f8",("nZ","nR"))    rr = rootgrp.createVariable("r","f8",("nR"))    zz = rootgrp.createVariable("z","f8",("nZ"))    brr[:] = br    btt[:] = bt    bzz[:] = bz    psii[:] = psi    rr[:] = r    zz[:] = z    rootgrp.close()        print( 'Created bField.nc')    return r,z, br,bz,bt,psidef plot_surf_plasma_params(W_surf, tile_shift_indices = [], Bangle_shift_indices = []):    profiles, r_wall, z_wall, r_target, z_target, rmrs = init(W_surf)        #store plasma parameters for cells along the W surfaces as a function of rmrs    W_surf = W_surf[:-1]    rmrsCoords = profiles.variables['rmrs_inner_target'][W_surf]    rmrs = profiles.variables['rmrs_inner_target_midpoints'][W_surf]    Bmag = profiles.variables['Bmag_inner_target'][W_surf]    Bangle = 180-profiles.variables['Bangle_inner_target'][W_surf]    te = profiles.variables['te_inner_target'][W_surf]    ti = profiles.variables['ti_inner_target'][W_surf]    ne = profiles.variables['ne_inner_target'][W_surf]    ni = profiles.variables['ni_inner_target'][:,W_surf]        flux = profiles.variables['flux_inner_target'][:,W_surf]    flux = np.abs(flux)        #calculate areally averaged B-field magnitude along W surface    r1 = r_target[:-1]    r2 = r_target[1:]    z1 = z_target[:-1]    z2 = z_target[1:]    dist = np.sqrt(np.power(r1-r2,2) + np.power(z1-z2,2))    area = np.pi*(r1+r2)*dist    Bmag_avg = sum(Bmag * area) / sum(area)    print('average Bmag:', Bmag_avg)    upper_margin = max(Bmag) - Bmag_avg    lower_margin = Bmag_avg - min(Bmag)    print('margins for Bmag:', upper_margin, ',', lower_margin)        #plot angle between B-field and normal incidence to the wall    plt.close()    if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')        plt.plot(rmrs,Bangle)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Angle [$\circ$]')    plt.title('B-Field Angle')    plt.show(block=False)    plt.savefig('plots/surface-profiles/Bangle.png')        #plot te along the W surfaces    plt.close()    if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')        plt.plot(rmrs,te)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Temperature [eV]')    plt.title('Te')    plt.savefig('plots/surface-profiles/te.png')        #plot ti along the W surfaces    plt.close()    if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')        plt.ylim(0,9)    plt.plot(rmrs,ti)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Temperature [eV]')    plt.title('Ti')    plt.savefig('plots/surface-profiles/ti.png')        #plot ne along the W surfaces    plt.close()    if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')        plt.plot(rmrs,ne)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Density [m$^{-3}$]')    plt.title('ne')    plt.savefig('plots/surface-profiles/ne.png')        #plot total ni along the W surfaces    plt.close()    if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')        ni_avg = np.sum(ni, axis=0)    plt.plot(rmrs,ni_avg)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Density [m$^{-3}$]')    plt.title('Total ni')    plt.savefig('plots/surface-profiles/niTot.png')        #plot ni along the W surfaces for deuterium    plt.close()    plt.plot(rmrs,ni[0],color='k',label='D 0')    plt.plot(rmrs,ni[1],color='firebrick',label='D 1+')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Density [m$^{-3}$]')    plt.title('D ion density along W surface')    plt.legend()    plt.savefig('plots/surface-profiles/niD.png')        #plot flux along the W surfaces for deuterium    plt.close()    if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')        plt.plot(rmrs,flux[0],color='k',label='D 0')    plt.plot(rmrs,flux[1],color='firebrick',label='D 1+')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Flux [m$^{-2}$s$^{-1}$]')    plt.title('D ion flux to W surface')    plt.legend()    plt.savefig('plots/surface-profiles/fluxD.png')        #plot ni along the W surfaces for carbon    plt.close()    plt.plot(rmrs,ni[2],color='k',label='C 0')    plt.plot(rmrs,ni[3],color='firebrick',label='C 1+')    plt.plot(rmrs,ni[4],color='darkorange',label='C 2+')    plt.plot(rmrs,ni[5],color='gold',label='C 3+')    plt.plot(rmrs,ni[6],color='limegreen',label='C 4+')    plt.plot(rmrs,ni[7],color='dodgerblue',label='C 5+')    plt.plot(rmrs,ni[8],color='mediumpurple',label='C 6+')    plt.yscale('log')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Density [m$^{-3}$]')    plt.title('C ion density along W surface')    plt.legend(loc='lower right')    plt.savefig('plots/surface-profiles/niC.png')        #plot carbon fraction along W surfaces    niC = ni[2] + ni[3] + ni[4] + ni[5] + ni[6] + ni[7] + ni[8]    ni = ni[0] + ni[1] + niC    Cfraction = 100*niC/ni    print('average carbon fraction along W surface:', np.average(Cfraction))    plt.close()    plt.plot(rmrs,Cfraction)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Carbon Fraction [%]')    plt.title('Carbon fraction along W surface')    plt.savefig('plots/surface-profiles/Cfraction.png')        #plot flux along the W surfaces for carbon    plt.close()     if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')                plt.plot(rmrs,flux[3],color='firebrick', label='C$^{1+}$')    plt.plot(rmrs,flux[4],color='darkorange',label='C$^{2+}$')    plt.plot(rmrs,flux[5],color='gold',label='C$^{3+}$')    plt.plot(rmrs,flux[6],color='limegreen',label='C$^{4+}$')    plt.plot(rmrs,flux[7],color='dodgerblue',label='C$^{5+}$')    plt.plot(rmrs,flux[8],color='mediumpurple',label='C$^{6+}$')    #plt.xlim(-0.06)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Flux [m$^{-2}$s$^{-1}$]')    #plt.yticks(fontsize=10.5)    plt.title('C ion flux to W surface', fontsize=16)    plt.legend()    plt.show(block=False)    plt.savefig('plots/surface-profiles/fluxC.png')        #plot Debye sheath width    epsilon_0 = 55.26349406    lambda_D = np.sqrt(epsilon_0 * te / (1e-18 * ni)) * 3 #in microns    print('Debye:',np.average(lambda_D),'um')        plt.close()     if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')        plt.plot(rmrs,lambda_D)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Width [$\mu$m]')    plt.title('Debye Sheath Width')    plt.savefig('plots/surface-profiles/Debye.png')        #plot Chodura sheath width    unit_charge = 1.602176634e-19    amu2kg = 1.6605402e-27    mi = 2 * amu2kg    cs = np.sqrt(unit_charge*(te+ti)/mi) #sound speed    r_Larmor = (mi/(unit_charge*Bmag)) * cs * 1000 * 3 #in milimeters    print('Chodura:',np.average(r_Larmor),'mm')        plt.close()     if tile_shift_indices != []:        for i,v in enumerate(tile_shift_indices):            if i==0: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed', label='Geometry\nVertices')            else: plt.axvline(x=rmrsCoords[v], color='k', linestyle='dashed')    if Bangle_shift_indices != []:        for i,v in enumerate(Bangle_shift_indices):            if i==0: plt.axvline(x=rmrs[v], color='k', linestyle='dotted', label='$\Delta\Psi_B$')            else: plt.axvline(x=rmrs[v], color='k', linestyle='dotted')                plt.plot(rmrs,r_Larmor)    plt.xlabel('D-Dsep [m]')    plt.ylabel('Width [mm]')    plt.title('Chodura Pre-Sheath Width')    plt.savefig('plots/surface-profiles/Chodura.png')        #electron temperature dependence of ionization rate    kte = np.arange(1,35,0.01)    x0 = 7.86    x1 = 16.37    x2 = 26.0    x3 = 38.2    x4 = 51.6    invtau0 = 1/(np.exp(x0/kte)/np.sqrt(kte))    invtau1 = 1/(np.exp(x1/kte)/np.sqrt(kte))    invtau2 = 1/(np.exp(x2/kte)/np.sqrt(kte))    invtau3 = 1/(np.exp(x3/kte)/np.sqrt(kte))    invtau4 = 1/(np.exp(x4/kte)/np.sqrt(kte))    plt.close()    plt.plot(kte, invtau0, 'firebrick', label='0 to 1')    plt.plot(kte, invtau1, 'darkorange', label='1 to 2')    plt.plot(kte, invtau2, 'gold', label='2 to 3')    plt.plot(kte, invtau3, 'limegreen', label='3 to 4')    plt.plot(kte, invtau4, 'dodgerblue', label='4 to 5')    plt.xlabel('Te [eV]')    plt.ylabel('Relative ionization rate [s$^{-1}$]')    plt.title('Te dependence of ionization rate for W')    plt.legend()    plt.savefig('plots/surface-profiles/IonizRate(Te)')        #ionization rate along surface    surf_IonizRate0 = ne/(np.exp(x0/te)/np.sqrt(te))    surf_IonizRate1 = ne/(np.exp(x1/te)/np.sqrt(te))    surf_IonizRate2 = ne/(np.exp(x2/te)/np.sqrt(te))    surf_IonizRate3 = ne/(np.exp(x3/te)/np.sqrt(te))    surf_IonizRate4 = ne/(np.exp(x4/te)/np.sqrt(te))    plt.close()    plt.plot(rmrs, surf_IonizRate0, 'firebrick', label='0 to 1')    plt.plot(rmrs, surf_IonizRate1, 'darkorange', label='1 to 2')    plt.plot(rmrs, surf_IonizRate2, 'gold', label='2 to 3')    plt.plot(rmrs, surf_IonizRate3, 'limegreen', label='3 to 4')    plt.plot(rmrs, surf_IonizRate4, 'dodgerblue', label='4 to 5')    plt.xlabel('D-Dsep [m]')    plt.ylabel('Relative ionization rate [s$^{-1}$]')    plt.title('W ionization rate along SAS-VW')    plt.legend()    plt.savefig('plots/surface-profiles/IonizRate')        returndef ionization_analysis_theory(dt, W_surf):    profiles, W_indices, r_wall, z_wall, r_target, z_target, rmrs = init(W_surf)    ADASFile = '../input/ADAS_Rates_W.nc'    ADAS = netCDF4.Dataset(ADASFile)        te = profiles.variables['te_inner_target'][W_surf]    gridTemperature_Ionization = ADAS.variables['gridTemperature_Ionization'][:] * 10 #assuming in 0.1 eV    IonizationRateGrid = np.abs(ADAS.variables['IonizationRateCoeff'][:][0,:,0])        IonizeRateInterpolated = np.interp(te,gridTemperature_Ionization,IonizationRateGrid)    tauSec = 1/IonizeRateInterpolated    tauIndex = np.array(tauSec/dt, dtype=int)    print(tauIndex)        returndef plot_2D_cross_sections(W_surf, varString, unitString, colorbarLimits, rzlim=False, saveBool=True, colormap='coolwarm'):    #useful for comparing against SOLPS-profiles to see what GITR sees    #GITR gets 2D profiles        profiles, r_wall, z_wall, r_target, z_target, rmrs = init(W_surf)        gridr = profiles.variables['gridr'][:]    gridz = profiles.variables['gridz'][:]    var = profiles.variables[varString][:]    var[np.where(var==0)] = 'nan'        if rzlim:        rlim = [1.38,1.57]        zlim = [1.09,1.25]                r_indices = np.empty(0, dtype='int')        z_indices = np.empty(0, dtype='int')                for i,v in enumerate(gridr):            if v>=rlim[0] and v<=rlim[1]:                r_indices = np.append(r_indices, i)                for i,v in enumerate(gridz):            if v>=zlim[0] and v<=zlim[1]:                z_indices = np.append(z_indices, i)        gridr = gridr[r_indices]        gridz = gridz[z_indices]        var = var[z_indices[0]:z_indices[-1]+1,r_indices[0]:r_indices[-1]+1]        plt.close()        plt.rcParams.update({'pcolor.shading':'auto'})    plt.rcParams.update({'image.cmap':colormap})    plt.plot(r_wall, z_wall, 'k-')    plt.plot(r_target[:-1], z_target[:-1], 'm')    plot = plt.pcolor(gridr,gridz,var)    plt.axis('Scaled')    if rzlim:        plt.xlim(rlim)        plt.ylim(zlim)    plt.colorbar(label='\n '+ unitString)    if colorbarLimits != []: plot.set_clim(vmin=colorbarLimits[0],vmax=colorbarLimits[1])    plt.xlabel('R [m]')    plt.ylabel('Z [m]')        plt.title(str(varString))    if saveBool:         plt.savefig('plots/2D/'+str(varString)+'.png')    else:        plt.show(block=True)    def compare_surface_profiles(W_surf, varString):    profiles, W_indices, r_wall, z_wall, r_target, z_target, rmrs = init(W_surf)        varDims = np.shape(profiles.variables[varString+'_inner_target'])    print('Var Dimensions:', varDims)        if len(varDims)==1:        #get SOLPS values along the target surface        varSOLPS = profiles.variables[varString+'_inner_target'][W_surf]        print('length of SOLPS var:',len(rmrs))                #interpolate GITR values along the target        gridz = profiles.variables['gridz'][:]        gridr = profiles.variables['gridr'][:]        varGITRgrid = profiles.variables[varString][:]        r_target = profiles.variables['r_inner_target_midpoints'][:][W_indices]        z_target = profiles.variables['z_inner_target_midpoints'][:][W_indices]                varGITR = scii.interpn((gridz,gridr),varGITRgrid,(z_target,r_target))        print('length of GITR var:',len(varGITR))        elif varString=='ni':         #sum SOLPS ni along the target surface to compare total density        varSOLPS = np.sum(profiles.variables[varString+'_inner_target'], axis=0)[W_surf]        print('length of SOLPS var:',len(rmrs))                #interpolate GITR values along the target        gridz = profiles.variables['gridz'][:]        gridr = profiles.variables['gridr'][:]        varGITRgrid = profiles.variables[varString][:]        r_target = profiles.variables['r_inner_target_midpoints'][:][W_indices]        z_target = profiles.variables['z_inner_target_midpoints'][:][W_indices]                varGITR = scii.interpn((gridz,gridr),varGITRgrid,(z_target,r_target))        print('length of GITR var:',len(varGITR))        else:        #average SOLPS values along the target surface to compare density-averaged values        ni_total = np.sum(profiles.variables['ni_inner_target'], axis=0)        varSOLPS_ns = profiles.variables[varString+'_inner_target'][:]/ni_total        ni_ns = profiles.variables['ni_inner_target'][:]        varSOLPS = -np.sum((varSOLPS_ns * ni_ns), axis=0)[W_surf]        #varSOLPS = -np.sum(profiles.variables[varString+'_inner_target'], axis=0)[W_surf]        print('length of SOLPS var:',len(rmrs))                #interpolate GITR values along the target        gridz = profiles.variables['gridz'][:]        gridr = profiles.variables['gridr'][:]        ni_grid = profiles.variables['ni'][:]        varGITRgrid = profiles.variables[varString][:]        r_target = profiles.variables['r_inner_target_midpoints'][:][W_indices]        z_target = profiles.variables['z_inner_target_midpoints'][:][W_indices]                ni = scii.interpn((gridz,gridr),ni_grid,(z_target,r_target))        varGITR = scii.interpn((gridz,gridr),varGITRgrid,(z_target,r_target))/ni        print('length of GITR var:',len(varGITR))        #plot and compare visually    plt.close()    plt.plot(rmrs,varSOLPS,'dodgerblue',label='SOLPS')    plt.plot(rmrs,varGITR,'gold',label='GITR')    plt.title(varString+' compared between grids')    plt.xlabel('D-Dsep [m]')    plt.ylabel(varString)    plt.yscale('log')    plt.legend()    plt.savefig('plots/gridComparison/compare_'+varString+'.png')if __name__ == "__main__":    #compare_surface_profiles(np.arange(16,25),'v')    #plot_2D_cross_sections(np.arange(16,25), 'Bz', 'B-Field Strength [T]', [-0.1,0.1], rzlim=True)    #plot_2D_cross_sections(np.arange(16,25), 'Er', 'E-Field Strength [V/m]', [])    #plot_2D_cross_sections(np.arange(16,25), 'te', 'Temperature [eV]', [])    #plot_2D_cross_sections(np.arange(16,25), 'ni', 'Density [m$^{-3}$]', [])    #plot_2D_cross_sections(np.arange(16,25), 'gradTi', '[eV/m]', [])    #plot_2D_cross_sections(np.arange(16,25), 'vz', 'Velocity  [m/s]', [-500,500], rzlim=True, colormap='coolwarm')    #ionization_analysis_theory(1e-8, np.arange(16,25))    plot_surf_plasma_params(np.arange(16,25), [2,6], [3,6])    '''    readEquilibrium(equilibrium_filename = 'assets/dg.equ', \                        W_indices = np.arange(16,25), \                        solps_geom = 'assets/b2fgmtry', \                        flip_Bt = True, \                        plot_variables = 1)'''